include ./includes/post-layout

  :markdown
    #WebRTC Parallel Processing (part 1)
  
    I did a little experiment with WebRTC and a CFD (Computational Fluid Dynamics) solver I wrote.
    I wanted to see what could be done with webRTC and browser parallel computing. First, I needed a problem that was 
    computationally intense and suitable to parallelization. CFD suited that class of problems and plus, coming from
    mechanical engineering, it was a type of problems I was decently familiar with.   

    CFD is a class of numerical methods to solve differential equations from fluid flow problems. We want to solve 
    a given set of equation to compute several fields like flow velocity, temperature and other physical properties.

    The methods used in this type of numerical analysis are iterative, meaning that you'll have to compute several solutions, each one 
    function of and closer to the final solution than the previous. When you use parallel computing techniques, you end up with a 
    lot of communications between nodes at each iteration. This way, the communication speed quickly becomes the bottleneck in the process.  
 
    In this first post, I'll write about the solver itself.  In a second posts, I'll write about how I used WebRtC to distribute 
    the computation across several browsers. In a third post, I'll write about performance considerations.

    ##The Poisson Equation

    The equation I'm solving is in the form of 

  .equation(lang='latex') \left(\frac{\partial ^2}{\partial x^2} + \frac{\partial ^2}{\partial y^2} \right) U(x,y) = b

  :markdown
    this equation describes aspects of physical behaviour in, for instance, heat transfer and fluid flow. Fluid flow problems 
    are based in the Navier Stokes equation and solving the poisson equation makes up a large amount of the computing time.
    
    In the equation above, the term *U(x,y)* represents the field we are interested in computing. Usually there's no 
    analytical solution to get *U*, hence the need to use numerical methods. However
    if we want to test the solver, we can replace *U* by a known function. 

    Considering a rectangular domain of witdth *w* and height *h*, 
    we have for instance:

  .equation(lang='latex') U(x,y) = cos \left( \pi \left( \frac{1}{2} - \frac{x}{w} \right) \right) sin \left( \pi \frac{y}{h} \right) 

  :markdown
    The field *U* plotted in *x*, *y* looks something like this:

    ![Analytical Field](assets/img/webrtc/analitical.png "Analytical Field")

  :markdown
    Replacing the first equation with this *U* function we get:

  .equation(lang='latex')
    | \left(\frac{\partial ^2}{\partial x^2} + \frac{\partial ^2}{\partial y^2} \right) U(x,y) = 
    | U(x,y) \left( -\frac{\pi^2}{h^2} - \frac{\pi^2}{w^2}  \right).

  :markdown
    Now we have a poisson equation with a known analytical solution.


  :markdown
    ##Numerical Model

    The next step is to discretize the equation with a first order central finite difference scheme
    and obtain an algebraic formula for *U* that we can code. 
    I won't enter in details about the deduction because this is an extensive topic but you can 
    find many[references](http://www.ece.utah.edu/~ece6340/LECTURES/Feb1/Nagel%202012%20-%20Solving%20the%20Generalized%20Poisson%20Equation%20using%20FDM.pdf) in the internet 
    
    Basically, the idea is to approximate the derivative in an array of points in the domain of the solution. The points are equally spread 
    in *x* and *y* like in the image bellow

    ![points](assets/img/webrtc/domain.png "Points")

    In the image, *h* is the distance between this points. In the x and y direction, this distance will be called *Δx* and *Δy*, respectively.
  
  .equation(lang='latex')
    | u'_{i,j} = - \frac{1}{-2/\Delta x^2 -2/ \Delta y^2} \left( \frac{u_{i,j-1} + u_{i,j+1}}{\Delta x^2} + \frac{u_{i+1,j} + u_{i-1,j} } {\Delta y^2} - U(x_j,y_i) \left( -\frac{\pi^2}{h^2} - \frac{\pi^2}{w^2}  \right) \right).


  :markdown
    We start with all points set to zero and compute the *u* for every point. We then repeat the process, but ussing the new values. 
    We repreat the process until there is no significant difference between the new values and the old ones.

  :markdown
    ##Javascript Implementation

    I implemented the solver in node which enabled me to test everithing first in my local machine. In CFD it's important to test 
    if the numerical method is being solved correctly, otherwise know as verification, and if the solution compares well with the 
    equations, also know as validations. I achieved this with a small test suit that checks priceisely this two steps.

    It's better now to jump to the implementations and I show you how to use it. You can find the implementation of the solver 
    on a[github repository](//github.com/fjsousa/poisson-solver). To install it just run 


    ```
      npm install fjsousa/poisson-solver
    ```
    
    Here's how to require and instantiate the solver:

    ```Javascript
      var Poisson = require('poisson-solver');

      //Set conditions
      var conditions = {
        w: 1,     
        h: 1,     
        n: 50,    
        m: 50     
      };

      //Initialize solver
      var poisson = new Poisson(conditions);

    ```

    Here, `w` and `h`are the width and height of the domain. In this case, we are choosing an unitary measuremnet. And `n` and `m` are
    the number of cells in the 2 dimentions. I was a but lazy here and only tested for situations when n = m. 

    Now we need to set boundary condtions. Acoording to our analitical solution, the edges of the domain are zero, so we'll create 
    4 arrays with zero elements, for the north, south, east and west boundaries:

    ```Javascript
      var N = [];
      var S = [];
      var E = [];
      var W = [];

      for (var i = 0; i < conditions.n; i++) {
        N[i] = S[i] = E[i] = W[i] = 0;
      }

      //Set Dirichlet boundary conditions to zero
      poisson.setBoundaryConditions(N, S, E, W);

    ```

    Now we are ready to start the solver. We call the method poisson.solver and just have to define the maximum number of iterations and the final 
    residue. 

    ```Javascript
      var maxItterations = 100000000;
      var maxResidue = 1E-9 ; 
      
      var output = poisson.solver( maxItterations, maxResidue);
      console.log('Solver converged with', output.iterations, 'iterations and', output.residue, 'residue.');
    ```

    ##Visualization

    Now we have the numarical solution and we can visualize it using the print method, 

    ```Javascript
      //Print solution
      poisson.print('./field.txt', poisson.u.old);
    ```

    ![Numerical Field](assets/img/webrtc/numerical.png "Numerical")

    In the next post, I'll show you how I developed from here and distributed this solver among several browsers tabs.



  