<!DOCTYPE html>
<html lang="en">
  <head>
    <title>this.data</title>
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/font.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
    <link href="//cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
</html>
<body>
  <div id="side-bar">
    <div id="header">
      <div id="title">this.data</div>
      <div id="author">
        <div id="name">Flávio Sousa</div>
        <div id="social-media"><a href="//pt.linkedin.com/pub/flávio-sousa/3a/a06/770/" target="_blank"><i class="fa fa-linkedin"></i></a><a href="//twitter.com/fjmarujo" target="_blank"><i class="fa fa-twitter"></i></a><a href="//github.com/fjsousa" target="_blank"><i class="fa fa-github"></i></a></div>
      </div>
    </div>
    <div id="menu"><a href="webrtc-part1.html"><span id="nav-item-title">WebRTC Part 1</span></a><span id="nav-item-date">(27-02-2015)</span><br><a href="webrtc-part2.html"><span id="nav-item-title">WebRTC Part 2</span></a><span id="nav-item-date">(20-03-2015)</span></div>
    <div id="mc_embed_signup">
      <form id="mc-embedded-subscribe-form" action="//github.us10.list-manage.com/subscribe/post?u=5b26850668dc6b3f84778ca5e&amp;id=cb5f4eedfe" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate="" class="validate">
        <div id="mc_embed_signup_scroll">
          <label for="mce-EMAIL">Subscribe to the mailing list</label>      
          <input id="mce-EMAIL" type="email" value="" name="EMAIL" placeholder="email address" required="" class="email">
          <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
          <div style="position: absolute; left: -5000px;">
            <input type="text" name="b_5b26850668dc6b3f84778ca5e_cb5f4eedfe" tabindex="-1" value="">
          </div>      
          <div class="clear">
            <input id="mc-embedded-subscribe" type="submit" value="Subscribe" name="subscribe" class="button">
          </div>
        </div>
      </form>
    </div>
    <div id="about">
      <p id="about-title">About: </p>
      <p>
        this.data is a blog about numbers, modelling 
        and coding in general
      </p>
    </div>
  </div>
  <div id="container">
    <div id="content"><h1 id="forest-fires-and-parallel-celular-automata">Forest fires and parallel celular automata</h1>
<p>When I was a young kid back in 2009, I was given the task to speed up a forest fire algoritm with GPUs. 
The library was used to predict the propagation of a forest fire taking in consideration several factors
like wind, terrain and fuel properties and it was already able to run a simulation quite fast. However, my 
supervisor&#39;s idea was to use the library to run uncertainty quantification and stochastic methods. This required 
to run several hundreds of simulation and then post processing the results to get statistics about fire propagation and error 
distributions. Each single simulation had to be optimized, otherwise the full amount of simulations couldn&#39;t be done 
faster than real time. </p>
<h2 id="dummy-algoritm">dummy algoritm</h2>
<p>Initially I tried a very dummy implementation from the serial version. The algoritm ran something like this:</p>
<ul>
<li><p>There&#39;s an outer loop that iterates over time and an inner loop that iterates in space, over the rows and coloums of the 
space domain.</p>
</li>
<li><p>the inner loops looks for active cells, and propagates the fire outward, to each one of the 8 neighbours</p>
</li>
<li><p>the ignition time of the neighbours is computed with the simple formula</p>
</li>
</ul>

      <div class="equation">$$ t + \frac{l}{ROS}$$</div><p>where ROS is called the rate of spread, basically the speed of the flame in that region, function of wind, moisture, terrain, etc.</p>
<p>This is what the algorithm looks like. Notice that each coloured square represents a portion of the terrain, 
and the colour the time. So red means that the cell will burn after than yellow or green, and much after the blue cells.</p>

      <canvas id="fgm-serial" width="400" height="400">Consider updating your browser.</canvas><p>The spatial loop run something like this:</p>
<pre><code class="lang-Javascript">
  function dumbSpatialLoop(){

    t = tn;
    tn = Infinity;


    //Spatial loop that looks for active cells, ie, cells with 
    //ignition time = t
    for ( row = 0; row &lt; rows; row++){
      for ( col = 0; col &lt; cols; col++){
        var idx = col + cols*row;

        //Update tn, so that tn is the minimum ignition time for all cells,
        //in a given iteration
        if ( ignitionMap[idx] &gt; t &amp;&amp; tn &gt; ignitionMap[idx] ){

          tn = ignitionMap[idx];
          continue;
        } 

        //skips cells that already burned
        if ( ignitionMap[idx] !== t )
          continue;

        //propagate fire for all 8 neighours
        for (var n = 0; n &lt; 8; n++){

          //neighbour index calc
          var ncol = col + ncols[n];
          var nrow = row + nrows[n];
          var nidx = ncol + nrow*cols;

          //Check if neighbour is inbound
          if ( !(nrow &gt;= 0 &amp;&amp; nrow &lt; rows &amp;&amp; ncol &gt;= 0 &amp;&amp; ncol &lt; cols))
            continue;

          // skip if cell has already burned
          if ( ignitionMap[nidx] &lt; t )
            continue;

          //Compute neighbour cell ignition time, based on the propagation speed
          // tcell = current_time + cell distance / flame_speed
          igntime = t + ndist[n] / ROS;


          //Update ignition time in the map only if the the current time is smaller
          if(igntime &lt; ignitionMap[nidx]){
            ignitionMap[nidx] = igntime;
          }

          //Update tn
          if( igntime &lt; tn )
            tn = igntime;
        }
      }
    }
</code></pre>
<p>Porting this algoritm to GPUs was very dumb and resulted in poor performance. Because of the way data was propagated from the center cell to the outward cells, I ended up with threads writing in other threads memory, ir race conditions.</p>
<p><img src="assets/img/fgm/outer.png" alt="Outer propagation" title="Outer Propagation"></p>
<p>The result was very poor performance and </p>
<p><img src="assets/img/fgm/dumb.png" alt="Outer propagation" title="Outer Propagation"></p>
<p>I needed something smarter.</p>
<p>This algoritm takes the very logic aproach of propagating the fire from a cell that is burning. 
Ignition times in surounding cells are calculated, as we have seen, like this:</p>
<pre><code class="lang-Javascript">
  igntime = t + ndist[n] / ROS;

  if(igntime &lt; ignitionMap[nidx]){
    ignitionMap[nidx] = igntime;
  }
</code></pre>
<p>In the end, when all cells are done, the igntion time in each cells is continuously updated, so that if two cells propagate to 
the same cells, the minimum time of the two is considered has the defenitive ignition time.</p>
<p>This also means that the algoritm imposes the condition that the ignition time of each cell, is the minimum of the propagation times from the surounding cells.</p>
<p>This has an importante way to turn things around, because now, insteade of computing outward ignition times in each neighbour, I 
compute the inner cell ignition time from each neighbour.</p>
<p>But now the question imposes, how can I compute ignition times from cells that haven&#39;t burned yet? </p>
<p>I can iterativly, starting from a random numerical field, impose the conditionin all cells, and iterativly 
reach a solution that I know is unique because of the condition being imposed .</p>
<p>Because of the data patern, I no longer have race conditions, and the algoritm is much faster because I no longer end up spending most of the time looking for empty cells.</p>
<p><img src="assets/img/fgm/inner.png" alt="Outer propagation" title="Outer Propagation"></p>
<p><img src="assets/img/fgm/smart.png" alt="Outer propagation" title="Outer Propagation"></p>

      <canvas id="fgm-parallel" width="400" height="400">Consider updating your browser.</canvas>
      <boom></boom>
      <div id="disqus_thread">    
        <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'this-data'; // required: replace example with your forum shortname
          
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>    
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.  	</a></noscript>
      </div>
    </div>
  </div>
  <div id="footer"></div>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-53583095-1', 'auto');
      ga('send', 'pageview');
    
    
  </script>
  <script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
  <script type="text/javascript" src="assets/src/rags.js"></script>
  <script type="text/javascript" src="assets/src/fgm-main.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>