<!DOCTYPE html>
<html lang="en">
  <head>
    <title>this.data</title>
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/font.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
    <link href="//cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
</html>
<body>
  <div id="side-bar">
    <div id="header">
      <div id="title">this.data</div>
      <div id="author">
        <div id="name">Flávio Sousa</div>
        <div id="social-media"><a href="//pt.linkedin.com/pub/flávio-sousa/3a/a06/770/" target="_blank"><i class="fa fa-linkedin"></i></a><a href="//twitter.com/fjmarujo" target="_blank"><i class="fa fa-twitter"></i></a><a href="//github.com/fjsousa" target="_blank"><i class="fa fa-github"></i></a></div>
      </div>
    </div>
    <div id="menu"><a href="webrtc-part1.html"><span id="nav-item-title">WebRTC Part 1</span></a><span id="nav-item-date">(27-02-2015)</span><br><a href="webrtc-part2.html"><span id="nav-item-title">WebRTC Part 2</span></a><span id="nav-item-date">(20-03-2015)</span></div>
    <div id="mc_embed_signup">
      <form id="mc-embedded-subscribe-form" action="//github.us10.list-manage.com/subscribe/post?u=5b26850668dc6b3f84778ca5e&amp;id=cb5f4eedfe" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate="" class="validate">
        <div id="mc_embed_signup_scroll">
          <label for="mce-EMAIL">Subscribe to the mailing list</label>      
          <input id="mce-EMAIL" type="email" value="" name="EMAIL" placeholder="email address" required="" class="email">
          <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
          <div style="position: absolute; left: -5000px;">
            <input type="text" name="b_5b26850668dc6b3f84778ca5e_cb5f4eedfe" tabindex="-1" value="">
          </div>      
          <div class="clear">
            <input id="mc-embedded-subscribe" type="submit" value="Subscribe" name="subscribe" class="button">
          </div>
        </div>
      </form>
    </div>
    <div id="about">
      <p id="about-title">About: </p>
      <p>
        this.data is a blog about numbers, modelling 
        and coding in general
      </p>
    </div>
  </div>
  <div id="container">
    <div id="content"><h1 id="forest-fires-and-parallel-cellular-automata">Forest Fires and Parallel Cellular Automata</h1>
<p>A few years ago, for my dissertation thesis, my supervisor gave me the task to speed up a forest fire algorithm with GPUs.
The starting point was a library called firelib. It was able to predict fire propagation speed and direction taking in consideration several factors
like wind, terrain and fuel properties and it was already able to run simulations quite fast. However, my 
supervisor&#39;s idea was to use the library to run uncertainty quantification and stochastic methods. This required 
to run several hundreds of simulations and then post processing the results to get statistics about fire propagation and error 
distributions. Each single simulation had to be optimized, otherwise the full amount of simulations couldn&#39;t be done 
faster than real time. </p>
<h2 id="dummy-algorithm">Dummy algorithm</h2>
<p>Initially I tried a very dummy implementation of the serial version. The algorithm ran something like this:</p>
<p>-An outer loop iterates over time and an inner loop iterates in space, over the rows and columns of the 
spatial domain.</p>
<p>-The inner loop looks for active cells and propagates the fire outwards, to each one of the 8 neighbours.</p>
<p>-The ignition time of each neighbour is computed with the formula:</p>

      <div class="equation">$$ t + \frac{l}{ROS}$$</div><p>where ROS is called the rate of spread, basically the flame speed in the neighbour direction, function of wind, moisture, terrain, etc.</p>

      <div class="fgm-wrapper">
        <canvas id="fgm-serial" width="400" height="400">Consider updating your browser.</canvas>
        <button onclick="dumb()" class="fgmrun">Run</button>
      </div><p>And this is how the propagation looks like. Notice that each square represents a portion of the terrain 
and the colour is just a representation of ignition times. So basically, red means that the cell will burn after the yellow or green ones, and much after the blue ones.</p>
<p>The spatial loop run something like this:</p>
<pre><code class="lang-Javascript">
  function dumbSpatialLoop(){

    t = tn;
    tn = Infinity;


    //Spatial loop that looks for active cells, ie, cells with 
    //ignition time = t
    for ( row = 0; row &lt; rows; row++){
      for ( col = 0; col &lt; cols; col++){
        var idx = col + cols*row;

        //Update tn, so that tn is the minimum ignition time for all cells,
        //in a given iteration
        if ( ignitionMap[idx] &gt; t &amp;&amp; tn &gt; ignitionMap[idx] ){

          tn = ignitionMap[idx];
          continue;
        } 

        //skips cells that already burned
        if ( ignitionMap[idx] !== t )
          continue;

        //propagate fire for all 8 neighours
        for (var n = 0; n &lt; 8; n++){

          //neighbour index calc
          var ncol = col + ncols[n];
          var nrow = row + nrows[n];
          var nidx = ncol + nrow*cols;

          //Check if neighbour is inbound
          if ( !(nrow &gt;= 0 &amp;&amp; nrow &lt; rows &amp;&amp; ncol &gt;= 0 &amp;&amp; ncol &lt; cols))
            continue;

          // skip if cell has already burned
          if ( ignitionMap[nidx] &lt; t )
            continue;

          //Compute neighbour cell ignition time, based on the propagation speed
          // tcell = current_time + cell distance / flame_speed
          igntime = t + ndist[n] / ROS;


          //Update ignition time in the map only if the the current time is smaller
          if(igntime &lt; ignitionMap[nidx]){
            ignitionMap[nidx] = igntime;
          }

          //Update tn
          if( igntime &lt; tn )
            tn = igntime;
        }
      }
    }
</code></pre>
<p>Porting this algorithm to GPUs in a straightforward way resulted in very poor performance. I associated each cell with a GPU thread and ended up with threads writing in each other&#39;s memory and dealling with race conditions. </p>
<p><img src="assets/img/fgm/outer.png" alt="Outer propagation" title="Outer Propagation"></p>
<p>Also, the process doesn&#39;t have a great degree of parallelism because at each time step, very few cells 
are actually propagating and thus, require computation. Here&#39;s the speedups for several scenarios with different values for wind, fuel and moisture:     </p>
<p><img src="assets/img/fgm/dumb.png" alt="Outer propagation" title="Outer Propagation"></p>
<p>As you can see, very far from the two orders of magnitude in performance increase. I need to work on something smarter.</p>
<h2 id="smarter-approach">Smarter approach</h2>
<p>The algorithm we&#39;ve seen takes the very logical approach of propagating the fire from a cell that is burning in the first place, and then from the ones that have ignited and etc. Ignition times in surrounding cells are calculated, as we have seen, like this:</p>
<pre><code class="lang-Javascript">
  igntime = t + ndist[n] / ROS;

  if(igntime &lt; ignitionMap[nidx]){
    ignitionMap[nidx] = igntime;
  }
</code></pre>
<p>During the process, the ignition time in each cell is continuously updated, so that if two cells propagate to 
the same cell, the minimum time of the two is considered and stored as the true ignition time.</p>
<p>Looking at the problem in another way, what we have, is a condition that says, that the ignition time of each cell, is the minimum of the propagation times from the surrounding cells.</p>
<p>From this, instead of computing outward ignition times in each neighbour, I 
compute the inner cell ignition time from each neighbour.</p>
<p>But now the question imposes, how can I compute ignition times from cells that haven&#39;t burned yet? </p>
<p>I can iterativly, starting from a random numerical field, impose the conditionin all cells, and iterativly 
reach a solution that I know is unique because of the condition being imposed .</p>
<p>Because of the data patern, I no longer have race conditions, and the algoritm is much faster because I no longer end up spending most of the time looking for empty cells.</p>
<p><img src="assets/img/fgm/inner.png" alt="Outer propagation" title="Outer Propagation"></p>
<pre><code class="lang-Javascript">
  function smartSpatialLoop(){

    for ( row = 0; row &lt; rows; row++){
      for ( col = 0; col &lt; cols; col++){
        var idx = col + cols*row;

        //skip ignition cell
        if (ignitionMap[idx] === 0)
          continue;

        var minArray = [];
        for (var n = 0; n &lt; 8; n++){

          //neighbour index calc
          var ncol = col + ncols[n];
          var nrow = row + nrows[n];
          var nidx = ncol + nrow*cols;

          //Check if neighbour is inbound
          if ( !(nrow &gt;= 0 &amp;&amp; nrow &lt; rows &amp;&amp; ncol &gt;= 0 &amp;&amp; ncol &lt; cols))
            continue;

          // compute igniton time considering that the flame moves from the neighbour to the 
          // center cell
          var igntime = ignitionMap[nidx] + ndist[n] / rosmap[nidx];
          minArray.push(igntime);

        }
        //associate the minimum of the propagation times to the ignition time 
        // of the center cell
        ignitionMap[idx] = Math.min.apply(null, minArray);;

      }
    }

  }
</code></pre>

      <div class="fgm-wrapper">
        <canvas id="fgm-parallel" width="400" height="400">Consider updating your browser.</canvas>
        <button onclick="smart()" class="fgmrun">Run</button>
      </div><p><img src="assets/img/fgm/smart.png" alt="Outer propagation" title="Outer Propagation"></p>

      <div id="link">paper</div>
      <div id="css">and responsiveness</div>
      <div id="link">do firelib</div>
      <div id="test">several devices</div>
      <div id="disqus_thread">    
        <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'this-data'; // required: replace example with your forum shortname
          
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>    
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.  	</a></noscript>
      </div>
    </div>
  </div>
  <div id="footer"></div>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-53583095-1', 'auto');
      ga('send', 'pageview');
    
    
  </script>
  <script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
  <script type="text/javascript" src="assets/src/rags.js"></script>
  <script type="text/javascript" src="assets/src/fgm-main.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>